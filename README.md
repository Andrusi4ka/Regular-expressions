# Regular expressions. jQuery

**[Результат домашнього завдання](https://andrusi4ka.github.io/Regular-expressions/)**

## Регулярні вирази та Метод replace

### Регулярні вирази

**Регулярні вирази** – це послідовності символів, що формують шаблон пошуку, який використовується для пошуку або заміни символів у рядках. Вони забезпечують потужний і гнучкий спосіб обробки тексту.

Літерал регулярного виразу створюється шляхом поміщення шаблону між слешами `/`, а функція конструктор `RegExp` дозволяє створювати регулярний вираз динамічно з рядка.<br><br>

**Приклад літерала регулярного виразу:**

```js
const patternLiteral = /hello/;
```

Цей регулярний вираз шукає відповідність слову "hello" у будь-якому рядку.<br><br>

**Приклад використання функції конструктора** `RegExp`**:**

```js
const patternConstructor = new RegExp('hello');
```
Обидва вирази використовуються для пошуку слова "hello" в тексті, але функція конструктор `RegExp` особливо корисна, коли шаблон пошуку визначається динамічно, наприклад, змінними або даними, отриманими в ході виконання програми.<br><br>

### Метод replace

Метод `replace` використовується для пошуку відповідностей у рядку з використанням регулярного виразу або простого рядка та заміни цих відповідностей на новий рядок. Цей метод повертає новий рядок, в якому одна або всі знайдені відповідності замінені на заданий рядок заміни, при цьому оригінальний рядок залишається без змін.<br><br>

**Приклад коду:**

Уявімо, що ми хочемо замінити слово "світ" на "Всесвіт" у рядку "Привіт, світ".

```js
const originalString = "Привіт, світ";
const newString = originalString.replace("світ", "Всесвіт");
```

У цьому прикладі `originalString` містить початковий рядок "Привіт, світ". Метод `replace` шукає слово "світ" у `originalString` і замінює його на "Всесвіт", результат зберігається у `newString`. Тепер `newString` містить "Привіт, Всесвіт".

Якщо нам потрібно замінити всі відповідності в рядку, ми можемо використати регулярний вираз з прапорцем `g` (глобальна заміна):

```js
const originalText = "Привіт, світ. Світ такий великий.";
const newText = originalText.replace(/світ/g, "Всесвіт");
```

Тепер `newText` буде містити "Привіт, Всесвіт. Всесвіт такий великий.", де обидва входження "світ" замінені на "Всесвіт".

Модифікатор `g` (глобальний пошук) в регулярних виразах використовується для пошуку всіх відповідностей у рядку, а не лише першої. Модифікатор `i` (ігнорування регістру) дозволяє здійснювати пошук без врахування регістру букв, тобто великих чи малих.

**Приклад коду з модифікаторами** `g` **та** `i` **:**

Розглянемо рядок "Привіт, світ. Світ такий великий." і замінимо всі входження слова "світ" (незалежно від регістру) на "Всесвіт".

```js
const originalText = "Привіт, світ. Світ такий великий.";
const newText = originalText.replace(/світ/gi, "Всесвіт");
```

У цьому прикладі, використовуючи `/світ/gi`, ми шукаємо всі входження слова "світ", ігноруючи регістру (так, слово "Світ" з великої літери також буде знайдене), і замінюємо їх на "Всесвіт". Таким чином, `newText` буде містити "Привіт, Всесвіт. Всесвіт такий великий.", де обидва входження "світ" і "Світ" замінені на "Всесвіт".

Використання модифікаторів `g` та `i` разом дозволяє більш гнучко управляти пошуком і заміною в рядках, забезпечуючи можливість замінити всі відповідності, незалежно від їх регістру.<br><br>

**Будь-який символ**

В регулярних виразах символ . (крапка) використовується для представлення будь-якого символу, за винятком символа нового рядка. Це означає, що він може відповідати будь-якому символу, який знаходиться на даній позиції в рядку.<br><br>

**Приклад коду:**

Припустимо, ми хочемо знайти перше входження будь-якого символу, за яким слідують літери "bc" в рядку "abc123".

```js
const text = "abc123";
const match = text.match(/.bc/);
```

## Оператори / Дужки / Спецсимволи

### Оператори повторення символів (*,+,?)

Оператори повторення символів у регулярних виразах дозволяють вказати, скільки разів символ або група символів може з'являтися в зіставленому рядку:
- `*` (зірочка) відповідає 0 або більше випадкам попереднього елемента.
- `+` (плюс) відповідає 1 або більше випадкам попереднього елемента.
- `?` (запитальний знак) робить попередній елемент необов'язковим, відповідаючи 0 або 1 випадку.

**Приклад коду:**

Розглянемо рядок "Ааааа, вулиця 12345!" і використаємо регулярні вирази для пошуку:
- Послідовностей літер "а", які з'являються один або більше разів.
- Цифр, які з'являються один або більше разів.
- Необов'язкового входження літери "у".

```js
const text = "Ааааа, вулиця 12345!";

// Знайти послідовності 'а' (одна або більше)
const lettersA = text.match(/а+/gi);

// Знайти послідовності цифр (одна або більше)
const digits = text.match(/\d+/g);

// Знайти необов'язкову літеру 'у'
const optionalLetter = text.match(/ву?лиця/gi);

console.log(`Послідовності 'а': ${lettersA}, Цифри: ${digits}, Необов'язкова 'у': ${optionalLetter}`);
```

У цьому прикладі:

- `/а+/gi` шукає одне або більше входжень літери "а", ігноруючи регістру. Він знайде "Ааааа" як одну послідовність.
- `/\\d+/g` знаходить одну або більше цифр, відповідно знаходить "12345".
- `/ву?лиця/gi` шукає слово "вулиця", де літера "у" є необов'язковою, таким чином знаходить "вулиця".

Ці оператори повторення дуже корисні для гнучкого пошуку в рядках, дозволяючи адаптувати регулярний вираз до різноманітних умов відповідності.

### Групувальні дужки

Групувальні дужки в регулярних виразах `()` використовуються для створення підвиразів усередині регулярного виразу. Це дозволяє нам застосовувати квантифікатори до цілого блоку символів, виконувати локальні пошуки або заміни, а також зберігати частини знайденого відповідного рядка для подальшого використання у вигляді груп.

**Приклад коду:**

Припустимо, ми хочемо знайти всі входження слова "коло" або "кіло" в рядку "коло, кілометр, кіло" і замінити їх на "круг".

```js
const text = "коло, кілометр, кіло";
const replacedText = text.replace(/(коло|кіло)/g, "круг");
```

У цьому прикладі використовуються групувальні дужки для створення підвиразу `(коло|кіло)`, який відповідає слову "коло" або "кіло". Оператор `|` всередині дужок означає "або". Модифікатор `g` використовується для пошуку всіх відповідностей у рядку. Результатом є рядок "круг, кілометр, круг", де всі входження "коло" та "кіло" замінені на "круг".

Цей приклад показує, як за допомогою групувальних дужок можна ефективно управляти пошуком і заміною в регулярних виразах, а також як це сприяє структуруванню шаблонів пошуку.<br><br>

### Екранування спецсимволів
Екранування спецсимволів у регулярних виразах полягає у використанні символа зворотного слеша `\\` перед спецсимволами, щоб вказати, що цей символ слід інтерпретувати буквально, а не як частину синтаксису регулярного виразу. Спецсимволи включають символи, які зазвичай використовуються в регулярних виразах для керування пошуком, наприклад `.`, `*`, `+`, `?`, `|`, `()`, `[]`, `{}`, `^`, `$` та інші.

**Приклад коду:**

Припустимо, ми хочемо знайти всі входження точки в рядку "Привіт. Це тестовий рядок. Завершено.".

```js
const text = "Привіт. Це тестовий рядок. Завершено.";
const dots = text.match(/\./g); // Використовуємо екранування для пошуку точок
```

У цьому прикладі `\.` екранує символ точки, що дозволяє нам шукати буквальні точки в рядку, а не використовувати точку як спецсимвол, що відповідає будь-якому символу. Модифікатор `g` застосовується для пошуку всіх входжень точок у рядку. Завдяки екрануванню ми можемо точно ідентифікувати і вилучити всі точки з рядка.

### Обмеження жадібності
Обмеження жадібності в регулярних виразах використовується для зміни стандартної жадібної поведінки квантифікаторів (`*`, `+`, `?`, `{n,}`), які за замовчуванням намагаються знайти найбільшу можливу відповідність до шаблону в рядку. Жадібні квантифікатори можуть бути обмежені шляхом додавання знака `?` безпосередньо після квантифікатора, що змушує їх шукати найменшу можливу відповідність.

**Приклад коду:**

Припустимо, ми хочемо знайти контент в HTML-тегах у рядку:
```html
<div>Привіт</div><div>Світ</div>
```

```js
const text = "<div>Привіт</div><div>Світ</div>";

// Жадібний пошук
const greedyMatch = text.match(/<div>.*<\/div>/);

// Обмеження жадібності
const nonGreedyMatch = text.match(/<div>.*?<\/div>/g);
```

У цьому прикладі:

- Перший вираз `/<div>.*<\\/div>/` є жадібним і знайде весь рядок `<div>Привіт</div><div>Світ</div>`, оскільки `.*` відповідає будь-якій кількості будь-яких символів між `<div>` і `</div>`, включаючи інші `<div>` теги.
- Другий вираз `/<div>.*?<\\/div>/` обмежує жадібність квантифікатора, додавши `?` після ``, що змушує його знайти найменшу можливу відповідність. Він знайде дві окремі відповідності: `<div>Привіт</div>` і `<div>Світ</div>`.

Цей приклад демонструє, як обмеження жадібності дозволяє більш точно контролювати пошук в рядках, забезпечуючи знаходження більш специфічних відповідностей.

## Фігурні дужки / Групи символів / Квадратні дужки

### Фігурні дужки

Фігурні дужки в регулярних виразах використовуються як квантифікатори, що дозволяють точно вказати кількість входжень символу або групи символів, які повинні бути знайдені в рядку для відповідності шаблону.

- `{n}` вказує, що попередній символ або група повинні зустрічатися рівно n разів.
- `{n,m}` вказує, що попередній символ або група повинні зустрічатися від n до m разів включно.
- `{n,}` вказує, що попередній символ або група повинні зустрічатися n або більше разів.
**Приклад коду:**

```js
const text = "оооо пііііііссссня 1111111111222";

// Відповідність рівно 4 о
const fourOs = text.match(/о{4}/);

// Відповідність від 2 до 5 і
const twoToFiveIs = text.match(/і{2,5}/);

// Відповідність 3 або більше 1
const threeOrMoreOnes = text.match(/1{3,}/);

console.log(`Чотири 'о': ${fourOs}, Від 2 до 5 'і': ${twoToFiveIs}, 3 або більше '1': ${threeOrMoreOnes}`);
```

У цьому прикладі:

- `/о{4}/` знаходить послідовність, де літера "о" з'являється рівно 4 рази.
- `/і{2,5}/` знаходить послідовність, де літера "і" з'являється від 2 до 5 разів.
- `/1{3,}/` знаходить послідовність, де цифра "1" з'являється 3 або більше разів.

Ці приклади демонструють, як за допомогою фігурних дужок можна вказати точну кількість символів, необхідних для відповідності, забезпечуючи більшу точність і гнучкість при роботі з регулярними виразами.

### Групи символів \s, \S, \w, \W, \d, \D

Групи символів у регулярних виразах дозволяють визначати широкі категорії символів за допомогою коротких позначень:

- `\\s` відповідає будь-якому пробільному символу (включає пробіл, табуляцію, переведення рядка тощо).
- `\\S` відповідає будь-якому символу, крім пробільних.
- `\\w` відповідає будь-якому словесному символу (включає літери, цифри та підкреслення).
- `\\W` відповідає будь-якому символу, що не є словесним символом.
- `\\d` відповідає будь-якій цифрі.
- `\\D` відповідає будь-якому символу, що не є цифрою.

**Приклад коду для кожної групи:**

```js
const text = "Привіт 123! ABC_def. \t\n";

// Знайти пробільні символи
const whitespaces = text.match(/\s/g);

// Знайти не-пробільні символи
const nonWhitespaces = text.match(/\S/g);

// Знайти словесні символи
const wordCharacters = text.match(/\w/g);

// Знайти не-словесні символи
const nonWordCharacters = text.match(/\W/g);

// Знайти цифри
const digits = text.match(/\d/g);

// Знайти не-цифрові символи
const nonDigits = text.match(/\D/g);

console.log(`Пробільні символи: ${whitespaces.length}, Не-пробільні символи: ${nonWhitespaces.length}`);
console.log(`Словесні символи: ${wordCharacters.length}, Не-словесні символи: ${nonWordCharacters.length}`);
console.log(`Цифри: ${digits.length}, Не-цифрові символи: ${nonDigits.length}`);
```

У цьому прикладі ми використовуємо різні групи символів для пошуку відповідностей в заданому тексті. Метод `match` з модифікатором `g` дозволяє знайти всі відповідності в рядку. Результати пошуку дають змогу побачити, скільки разів кожен тип символів зустрічається в тексті, демонструючи гнучкість і потужність регулярних виразів для аналізу та обробки тексту.

### Квадратні дужки '[' та ']'

Квадратні дужки `[]` у регулярних виразах використовуються для створення символьних класів, які відповідають будь-якому одному символу з вказаних всередині дужок. Це дозволяє вказати набір символів, які можуть зустрічатися на даній позиції в шаблоні, що шукається.

**Приклад коду:**

Припустимо, ми хочемо знайти всі входження літер "а", "б", або "в" у рядку "август березень вересень".

```js
const text = "август березень вересень";
const matches = text.match(/[абв]/g);
```

У цьому прикладі `[абв]` визначає символьний клас, який відповідає будь-якій з трьох літер: "а", "б", або "в". Модифікатор `g` (глобальний пошук) використовується для пошуку всіх відповідностей у рядку, а не лише першої знайденої. Результатом буде масив символів, які відповідають цим критеріям у рядку "август березень вересень".

### Коли користуватись групами, а коли [ ]?

Використання груп `\\s`, `\\S`, `\\w`, `\\W`, `\\d`, `\\D` та символьних класів `[]` залежить від потреби шаблону пошуку в регулярних виразах:

- Групи `\\s`, `\\S`, `\\w`, `\\W`, `\\d`, `\\D` є зручними для швидкого визначення загальних категорій символів (пробільні символи, не-пробільні символи, словесні символи, не-словесні символи, цифри, не-цифрові символи). Вони надають простий спосіб вказати на широкі класи символів без потреби перераховувати кожен символ індивідуально.
- Символьні класи `[]` використовуються, коли потрібно вказати конкретний набір символів для пошуку, який може не вписуватися в загальні категорії, або коли потрібно комбінувати різні символи, які не охоплюються однією категорією.

**Приклад коду:**
**Пошук словесних символів та цифр в рядку:**

```js
const text = "Password123!";

// Використання \w та \d
const wordCharsAndDigits = text.match(/[\w\d]/g);

// Використання символьних класів []
const specificChars = text.match(/[Pswrd123]/g);
```

У цьому прикладі:
- `[\\w\\d]` шукає будь-які словесні символи та цифри, комбінуючи дві загальні групи в одному символьному класі.
- `[Pswrd123]` вказує на конкретний набір символів, які ми хочемо знайти, що є прикладом ситуації, коли використання символьних класів [] є більш відповідним для задачі.

Вибір між використанням загальних груп символів та символьних класів залежить від специфіки задачі пошуку або заміни тексту, дозволяючи вибрати найефективніший метод для досягнення бажаного результату.

### Особливості кирилиці

При роботі з кирилицею в регулярних виразах варто враховувати, що стандартні словесні групи символів, такі як `\\w` та `\\W`, зазвичай визначають символи латиниці, цифри та підкреслення, і можуть не включати літери кирилиці. Тому, для пошуку або маніпуляцій з текстом, написаним кирилицею, потрібно використовувати символьні класи `[]` з явним вказівкам діапазонів кириличних символів або конкретних кириличних літер.

**Приклад коду, пошук усіх кириличних літер в рядку:**

```js
const text = "Привіт, світ! 123";

// Пошук усіх кириличних літер
const cyrillicLetters = text.match(/[а-яА-ЯіІїЇєЄґҐ]/g);

console.log(`Кириличні літери: ${cyrillicLetters}`);
```

У цьому прикладі `[а-яА-ЯіІїЇєЄґҐ]` вказує на діапазон кириличних літер, включаючи "і", "І", "ї", "Ї", "є", "Є", "ґ", "Ґ", що є специфічними для української абетки, а також загальні діапазони для малих та великих літер. Використання цього символьного класу дозволяє ефективно здійснити пошук усіх кириличних літер у рядку.

## Початок і кінець рядка / Вертикальна лінія / Зворотний слеш

### Початок '^' і кінець '$' рядка

У регулярних виразах символ `^` використовується для вказівки на початок рядка, а символ `$` - для вказівки на кінець рядка. Ці символи дозволяють точно визначити, де має починатися або закінчуватися шаблон відповідності у тексті.

**Приклад коду, перевірка, чи рядок починається з "Привіт" і закінчується на "світ!":**

```js
const text = "Привіт, світ!";

// Перевірка на початок рядка
const startsWithHello = /^Привіт/.test(text);

// Перевірка на кінець рядка
const endsWithWorld = /світ!$/.test(text);

console.log(`Рядок починається з "Привіт": ${startsWithHello}`);
console.log(`Рядок закінчується на "світ!": ${endsWithWorld}`);
```

У цьому прикладі:

- `/^Привіт/` шукає відповідності, де "Привіт" з'являється на початку рядка.
- `/світ!$/` шукає відповідності, де "світ!" з'являється в кінці рядка.

Цей приклад демонструє, як використовуючи `^` і `$`, можна точно визначити місце знаходження шаблону в рядку, що є корисним для перевірки формату введення, адрес електронної пошти, номерів телефонів та інших подібних даних.

### "Або" через вертикальну лінію |

У регулярних виразах вертикальна лінія `|` використовується для вказівки альтернативи, або "або", що дозволяє визначити кілька шаблонів пошуку в одному виразі. Це означає, що шаблон відповідає одному з вказаних варіантів.

**Приклад коду, пошук в рядку слів "кіт" або "пес" або "птах":**

```js
const text = "У мене є кіт, пес і птах.";

// Пошук слів "кіт", "пес" або "птах"
const foundAnimals = text.match(/кіт|пес|птах/g);

console.log(`Знайдені тварини: ${foundAnimals}`);
```

У цьому прикладі регулярний вираз `/кіт|пес|птах/g` використовує вертикальну лінію | для вказівки, що ми шукаємо одне зі слів: "кіт", "пес" або "птах". Модифікатор `g` (глобальний пошук) використовується для знаходження всіх відповідностей у рядку.

Цей приклад демонструє, як за допомогою вертикальної лінії `|` можна ефективно шукати різні варіанти в тексті, забезпечуючи гнучкість і ефективність при роботі з регулярними виразами.

### Проблема зворотного слешу

Проблема зі зворотним слешем `\\` у регулярних виразах та рядках виникає через його використання як екрануючого символу (escape character). У рядках JavaScript зворотний слеш використовується для вказівки спеціальних символів або екранування символів, які мають спеціальне значення. У регулярних виразах зворотний слеш також використовується для екранування спеціальних символів, що може призвести до необхідності подвійного екранування при їх використанні у рядкових літералах.

**Приклади коду, заміна одиночного зворотного слеша на '!'**

```js
'\\ \\ \\\\'.replace(/\\/g, '!');
```

У цьому прикладі шукаються всі одиночні зворотні слеші `\\` в рядку і замінюються на `!`. Вхідний рядок містить одиночні та подвійні зворотні слеші, але в JavaScript для представлення одиночного зворотного слеша потрібно використати подвійний слеш `\\\\`. Регулярний вираз `/\\\\/g` шукає кожен одиночний зворотний слеш (екранований слеш у регулярному виразі) в рядку і замінює його на `!`.

**Заміна подвійного зворотного слеша на '!'**

```js
'\\ \\ \\\\'.replace(/\\\\/g, '!');
```

Тут ми шукаємо подвійні зворотні слеші `\\\\` в рядку і замінюємо їх на `!`. В регулярному виразі `/\\\\\\\\/g` кожен зворотний слеш екранований ще одним зворотним слешем, тому для відповідності подвійному слешу в рядку потрібно використати чотири зворотні слеші в регулярному виразі.

Ці приклади ілюструють, як правильно використовувати зворотні слеші в рядках і регулярних виразах JavaScript, а також важливість екранування для досягнення бажаних результатів пошуку та заміни.

## Метод test & match / Кишені

### Метод test

Метод `test` є методом об'єкта RegExp у JavaScript і використовується для перевірки наявності збігів регулярного виразу в рядку. Він повертає логічне значення: `true`, якщо в рядку знайдено відповідність заданому регулярному виразу, і `false` — у протилежному випадку. Цей метод є корисним для валідації введення або швидкої перевірки тексту на відповідність певному шаблону.

**Приклад коду, перевірка формату електронної пошти:**

```js
const emailPattern = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/;
const email = "example@mail.com";

const isValidEmail = emailPattern.test(email);

console.log(`Чи валідний email "${email}": ${isValidEmail}`);
```

У цьому прикладі регулярний вираз визначає шаблон для перевірки формату електронної адреси:

- `^[a-zA-Z0-9._-]+` вказує на початок рядка і один або більше символів, що можуть включати літери (великі та малі), цифри, точки, підкреслення та дефіси.
- `@[a-zA-Z0-9.-]+` вимагає наявності символа @, за яким слідує один або більше символів, що можуть включати літери, цифри, точки та дефіси.
- `\\.[a-zA-Z]{2,6}$` вимагає наявності точки, за якою слідує від 2 до 6 літер, що індикують домен верхнього рівня. Символ $ вказує на кінець рядка.

Метод `test` використовується для перевірки, чи відповідає вказана електронна адреса заданому шаблону, і повертає `true`, якщо електронна адреса валідна, або `false`, якщо не валідна. Цей підхід є стандартним при валідації введення користувача.

### Метод match

Метод `match`, який використовується в рядках JavaScript, застосовує регулярний вираз до рядка і повертає масив усіх знайдених відповідностей. Коли використовується з модифікатором `g` (глобальний пошук), метод повертає масив усіх відповідностей в рядку. Без модифікатора `g`, `match` повертає масив, що містить першу відповідність та додаткову інформацію про неї, наприклад, позицію збігу та групи захоплення.

**Приклад коду, пошук усіх відповідностей (з модифікатором g):**

```js
const text = "Котик, котик, де твій носик?";
const patternWithG = /котик/gi;

const matchesWithG = text.match(patternWithG);
console.log(`Знайдені відповідності з 'g': ${matchesWithG}`);
```

У цьому прикладі використовується модифікатор `g` для пошуку всіх відповідностей слова "котик" у тексті, незалежно від регістру, завдяки `i` (ігнорування регістру). Результатом буде масив з усіма знайденими відповідностями.

**Приклад коду, пошук першої відповідності (без модифікатора g):**

```js
const patternWithoutG = /котик/i;

const matchesWithoutG = text.match(patternWithoutG);
console.log(`Перша відповідність без 'g': ${matchesWithoutG[0]}`);
```

Без модифікатора `g`, `match` повертає масив, де перший елемент — це знайдена відповідність, а масив також містить додаткові властивості, такі як індекс збігу в рядку та вхідний рядок. У цьому випадку виводиться лише перша відповідність.

Ці приклади ілюструють різницю у поведінці методу `match` залежно від використання модифікатора `g`, надаючи можливість або отримати всі відповідності у тексті, або зосередитися на деталях першої знайденої відповідності.

### Кишені

**Групи захоплення (кишені) для методу** `match` **без модифікатора** `g`

Коли використовується метод `match` без модифікатора `g` на регулярному виразі, який містить групи захоплення (вказані у круглих дужках), результатом є масив, де перший елемент містить повний збіг, а наступні елементи — це ті, що відповідають кожній групі захоплення у регулярному виразі. Ці додаткові елементи масиву часто називають "кишенями" або "групами захоплення", і вони дозволяють ізолювати частини збігу для подальшої обробки.

**Приклад коду, аналіз URL за допомогою груп захоплення:**

```js
const url = "https://www.example.com:80/path?query=test#hash";
const pattern = /^(https?):\/\/([^:/]+)(?::(\d+))?([^?#]*)(\?[^#]*)?(#.*)?$/;

const match = url.match(pattern);

console.log(`Протокол: ${match[1]}`);
console.log(`Хост: ${match[2]}`);
if (match[3]) {
    console.log(`Порт: ${match[3]}`);
}
console.log(`Шлях: ${match[4]}`);
if (match[5]) {
    console.log(`Запит: ${match[5]}`);
}
if (match[6]) {
    console.log(`Хеш: ${match[6]}`);
}
```

У цьому прикладі регулярний вираз розбиває URL на компоненти: протокол, хост, порт, шлях, рядок запиту та фрагмент (хеш). Кожна група захоплення в регулярному виразі відповідає одному з цих компонентів і доступна як окремий елемент у результаті, що повертається методом `match`. Це дозволяє легко витягти та використати інформацію з URL для подальшої обробки або валідації.

Цей приклад ілюструє, як за допомогою методу `match` і груп захоплення можна ефективно аналізувати складні рядки та ізолювати необхідну інформацію для використання в програмі.

**Групи захоплення (кишені) всередині replace**

Кишені всередині методу `replace` в регулярних виразах використовуються для вставки частин збігу, отриманих за допомогою груп захоплення, у новий рядок заміни. Вони дозволяють динамічно маніпулювати знайденим текстом, використовуючи інформацію, ізольовану регулярним виразом через групи захоплення, які позначаються круглими дужками. У рядку заміни можна посилатися на ці групи захоплення, використовуючи синтаксис `$n`, де `n` — номер групи захоплення.

**Приклад коду, форматування дати з "рррр-мм-дд" в "дд/мм/рррр":**

```js
const dateString = "2023-01-26";
const formattedDate = dateString.replace(/(\d{4})-(\d{2})-(\d{2})/, "$3/$2/$1");

console.log(`Вихідний формат дати: ${dateString}`);
console.log(`Форматована дата: ${formattedDate}`);
```

У цьому прикладі регулярний вираз `(\\d{4})-(\\d{2})-(\\d{2})` використовується для визначення груп захоплення, які відповідають року, місяцю та дню в існуючому форматі дати "рррр-мм-дд". При заміні використовується синтаксис `$3/$2/$1` для вставки дня, місяця та року у новий формат "дд/мм/рррр".

Цей метод демонструє, як можна ефективно використовувати групи захоплення всередині методу `replace` для динамічної модифікації тексту, забезпечуючи гнучкість при роботі з рядками.

Кишені за замовчуванням всередині `replace`
У методі `replace` регулярних виразів JavaScript існують спеціальні кишені за замовчуванням, які дозволяють вставляти певні частини рядка під час заміни, не вдаючись до явного визначення груп захоплення:

- `` $` `` – вставляє частину рядка, що знаходиться до збігу.
- `$'` – вставляє частину рядка, що знаходиться після збігу.
- `$&` – вставляє весь знайдений збіг.
- `$$` – вставляє знак долара $.

**Приклад коду, застосування спеціальних кишень за замовчуванням у методі** `replace`:

```js
const text = "Квіти ростуть на галявині.";
const pattern = /ростуть/;

const result = text.replace(pattern, "($`) замінено на $& ($')");
console.log(result);
```

У цьому прикладі ми шукаємо слово "ростуть" у рядку "Квіти ростуть на галявині." і замінюємо його на рядок, який включає частину рядка до збігу ``` $`` ```, сам збіг `$&`, і частину рядка після збігу `$'`. Результатом буде: "Квіти (Квіти ) замінено на ростуть ( на галявині.)."

Цей приклад демонструє, як можна використовувати спеціальні кишені за замовчуванням всередині методу `replace` для додавання контексту до заміни або для більш складних маніпуляцій з текстом під час заміни, забезпечуючи гнучкість і потужні можливості для роботи з рядками.

## Незберігаючі дужки & Позитивний та негативний перегляд

### Незберігаючі дужки

Незберігаючі дужки в регулярних виразах використовуються для групування частин виразу без створення кишені захоплення. Це означає, що підвираз всередині таких дужок враховується при збігу, але результат захоплення не зберігається для подальшого використання. Синтаксис для незберігаючих дужок — `(?:вираз)`.

**Приклад коду, застосування незберігаючих дужок для вибору слів без створення кишені захоплення:**

```js
const text = "Кіт спить, собака бігає, птах літає.";
const pattern = /(?:кіт|собака|птах) (спить|бігає|літає)/gi;

const matches = text.match(pattern);
console.log(`Знайдені відповідності: ${matches}`);
```

У цьому прикладі використовуються незберігаючі дужки для групування слів "кіт", "собака", "птах" без створення кишені захоплення для цієї групи. Друга група `(спить|бігає|літає)` використовується для захоплення та зберігання дії, яку виконує кожна тварина. Результатом буде масив знайдених відповідностей, де кожен елемент масиву містить збіги цілих фраз, але без окремого збереження першої частини у кишені захоплення.

Цей приклад демонструє, як незберігаючі дужки можуть бути корисними для групування частин регулярного виразу для управління пріоритетом або логікою збігу, не перевантажуючи результати зайвими даними.

### Позитивний та негативний перегляд

Позитивний та негативний перегляд (перевірка) у регулярних виразах дозволяє виконувати пошук в рядку за умови наявності або відсутності певного шаблону після або перед заданою позицією, не включаючи сам шаблон у збіг.

- **Позитивний перегляд вперед** `(?=вираз)` використовується для пошуку відповідності, за якою безпосередньо слідує вказаний вираз.
- **Негативний перегляд вперед** `(?!вираз)` шукає відповідність, за якою безпосередньо не слідує вказаний вираз.
- **Позитивний перегляд назад** `(?<=вираз)` використовується для пошуку відповідності, яка безпосередньо передує вказаному виразу.
- **Негативний перегляд назад** `(?<!вираз)` шукає відповідність, перед якою безпосередньо не стоїть вказаний вираз.

**Приклад коду, використання позитивного та негативного перегляду вперед для фільтрації слів:**

```js
const text = "кіт1, кіт2, кітА, кітБ, кітС";

// Позитивний перегляд вперед: шукаємо "кіт", за яким слідує цифра
const positiveLookahead = text.match(/кіт(?=\d)/g);
console.log(`Позитивний перегляд вперед: ${positiveLookahead}`);

// Негативний перегляд вперед: шукаємо "кіт", за яким не слідує цифра
const negativeLookahead = text.match(/кіт(?!\d)/g);
console.log(`Негативний перегляд вперед: ${negativeLookahead}`);
```

У цьому коді:

- **Позитивний перегляд вперед** `(/кіт(?=\\d)/g)` шукає всі випадки "кіт", за якими безпосередньо слідує цифра. Він знаходить "кіт1" та "кіт2", тобто ["кіт", "кіт"].
- **Негативний перегляд вперед** `(/кіт(?!\\d)/g)` шукає "кіт", за яким не слідує цифра. Він знаходить "кітА", "кітБ", та "кітС", знову ж таки повертаючи "кіт" без наступних символів, що відповідають умові негативного перегляду вперед.
